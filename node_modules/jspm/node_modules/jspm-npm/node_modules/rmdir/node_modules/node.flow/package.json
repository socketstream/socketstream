{
  "name": "node.flow",
  "version": "1.2.3",
  "description": "A deadly simple flow control package for node.js",
  "keywords": [
    "flow",
    "node.flow",
    "flow control",
    "async",
    "sync",
    "steps"
  ],
  "author": {
    "name": "dreamerslab",
    "email": "ben@dreamerslab.com"
  },
  "dependencies": {
    "node.extend": "1.0.8"
  },
  "devDependencies": {
    "should": "2.1.1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/dreamerslab/node.flow.git"
  },
  "main": "index",
  "engines": [
    "node >= 0.4.0"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "http://en.wikipedia.org/wiki/MIT_License"
    }
  ],
  "readme": "# node.flow\n\nA deadly simple flow control package for node.js\n\n\n\n## Description\n\nThe asynchronous nature of javascript is what makes it so powerful. However sometimes you just need to do stuffs synchronously without blocking the event loop. Stuffs like query database in a loop with ids to assemble a hash, compressing a bunch of files in groups and compare with the old ones. You could easily end up with nested callbacks without using a flow control package.\n\nWith node.flow you can set a work flow doing things one by one or in parallel, wait for all things are done in the parallel tasks to do the next task. You can set some default arguments for all tasks, giving each task its own arguments or pass task results to the next task as its arguments. The following code shows some base usage and the syntax of this package.\n\n    // setup db schema and connection\n    require( './setup' );\n\n    var Flow     = require( '../../lib/flow' );\n    var mongoose = require( 'mongoose' );\n    var User     = mongoose.model( 'User' );\n    var data     = require( './data' );\n\n    // start a new flow\n    var flow  = new Flow;\n    var users = {};\n\n    // delete all users before start\n    flow.series( function ( next ){\n      User.remove( function ( err, count ){\n        next();\n      });\n    });\n\n    // insert records from source data\n    data.users.forEach( function ( user ){\n      flow.parallel( function ( user, ready ){\n        new User( user ).save( function ( err, user ){\n          ready();\n        });\n      }, user );\n    });\n\n    // we must set an end point for parallel tasks\n    flow.join();\n\n    // find matching records\n    data.names.forEach( function ( name ){\n      flow.parallel( function( name, ready ){\n        User.findOne({\n          name : name\n        }, function ( err, user ){\n          users[ name ] = user;\n          ready();\n        });\n      }, name );\n    });\n\n    flow.join();\n\n    // print out records and disconnect\n    flow.end( function(){\n      console.log( users );\n      mongoose.disconnect();\n    });\n\n\n\n## Requires\n\nCheckout `package.json` for dependencies.\n\n\n\n## Installation\n\nInstall node.flow through npm\n\n    npm install node.flow\n\n\n\n## Usage\n\n> Require the module before using\n\n    var Flow = require( 'node.flow' );\n\n\n\n### new Flow( arg1, arg2, ... );\n\nStart a new flow.\n\n#### Arguments\n\n> arg1, arg2, ...\n\n    type: Function | String | Array | Object | Boolean\n    desc: arguments to be passed to the new flow as defaults.\n\n#### Example code\n\n    var flow = new Flow( 'bibi', 22, true );\n\n\n\n### flow.series( task, arg1, arg2, ... );\n\nAdd series task to the flow stack.\n\n#### Arguments\n\n> task\n\n    type: Function\n    desc: Task function to be called in series.\n\n> arg1, arg2, ...\n\n    type: Function | String | Array | Object | Boolean\n    desc: Arguments to be passed to the task function( optional ).\n\n#### Example code\n\n    var Flow = require( 'node.flow' );\n    var flow = new Flow();\n\n    // Add a task function, the last argument in the task callback\n    // is always the next task\n    flow.series( function( name, sort, next ){\n      User.find({\n        name : name\n      }).sort( sort, -1 ).run( function ( err, users ){\n        // call the next series task\n        next( users );\n      });\n\n    // 'bibi' will be passed to the task function as the first argument `name`\n    // and 'created_at' will be the second argument `sort`\n    // you can series as many arguments as you want\n    }, 'bibi', 'created_at' );\n\n\n\n### flow.parallel( task, arg1, arg2, ... );\n\nAdd parallel task to the flow stack.\n\n#### Arguments\n\n> callback\n\n    type: Function\n    desc: Task function to be called in parallel.\n\n> arg1, arg2, ...\n\n    type: Function | String | Array | Object | Boolean\n    desc: Arguments to be passed to the task function( optional ).\n\n#### Example code\n\n    var Flow = require( 'node.flow' );\n    var flow = new Flow();\n\n    flow.parallel( function( name, sort, ready ){\n      User.find({\n        name : name\n      }).sort( sort, -1 ).run( function ( err, users ){\n        ready( users );\n      });\n    }, 'bibi', 'created_at' );\n\n\n\n### flow.join();\n\nSet an end point for a group of parallel tasks.\n\n#### Example code\n\n    var Flow = require( 'node.flow' );\n    var flow = new Flow();\n\n    flow.parallel( function( name, sort, ready ){\n      User.find({\n        name : name\n      }).sort( sort, -1 ).run( function ( err, users ){\n        ready( users );\n      });\n    }, 'bibi', 'created_at' );\n\n    flow.join();\n\n\n\n### flow.error( callback );\n\nError handler for in case there is any.\n\n#### Arguments\n\n> callback\n\n    type: Function\n    desc: Error handler to break the flow.\n\n#### Example code\n\n    var Flow = require( 'node.flow' );\n    var flow = new Flow();\n\n    flow.error( function ( err ){\n      console.log( err );\n    });\n\n\n\n### flow.end( callback, arg1, arg2, ... );\n\nCall the tasks one after another in the stack.\n\n#### Arguments\n\n> callback\n\n    type: Function\n    desc: The last callback to be called at the very end after all tasks are done\n\n> arg1, arg2, ...\n\n    type: Function | String | Array | Object | Boolean\n    desc: Arguments to be passed to the callback function( optional )\n\n#### Example code\n\n    var Flow = require( 'node.flow' );\n    var flow = new Flow();\n    var users = {};\n\n    // find users with the given names\n    [ 'fifi', 'jenny', 'steffi' ].forEach( function ( name ){\n      // assign 3 parallel tasks searching for users\n      flow.parallel( function( users, name, ready ){\n        User.findOne({\n          name : name\n        }, function ( err, user ){\n          users[ name ] = user;\n          ready();\n        });\n      }, users, name )\n    });\n\n    flow.join();\n\n    // print out the search results\n    flow.end( function( users ){\n      console.log( users );\n    });\n\n\n\n## Arguments merge and overwrite\n\nYou can set some default arguments for all tasks, giving each task its own arguments or pass task results to the next task as its arguments. The priority is `argements from last task` > `argements for each task` > `default argements`. Which means `default argements` will be merge into `argements for each task` and finally merge into `argements from last task` than pass to the next task. However with parallel tasks it works a little different. Results from parallel tasks will be push to a stack, when all parallel tasks are done the result stack will be the first argument assign to `argements for each task` unless the result stack is empty. Checkout the parallel example for a clear view.\n\n\n\n## Chainability\n\nYou can either choose to chain your methods or not up to your personal taste. Both of the following syntax works.\n\n    // chaining all methods\n    flow.series( function (){\n      // do stuffs ...\n    }).parallel( function (){\n      // do stuffs ...\n    }).parallel( function (){\n      // do stuffs ...\n    }).join().\n    series( function (){\n      // do stuffs ...\n    end( function (){\n      // all done callback\n    });\n\n    // seperate all methods\n    flow.series( function (){\n      // do stuffs ...\n    });\n\n    flow.parallel( function (){\n      // do stuffs ...\n    });\n\n    flow.parallel( function (){\n      // do stuffs ...\n    });\n\n    flow.join();\n\n    flow.series( function (){\n      // do stuffs ...\n    });\n\n    flow.end( function (){\n      // all done callback\n    });\n\n## Examples\n\n> Checkout the `examples` folder for more details.\n\n### series\n\n> Demonstrate the basic usage of series task and syntax. We use setTimeout to simulate a time consuming io operation. We can see how the arguments are merged and overwrote in the example.\n\n    $ cd /path/to/node.flow/examples/series\n    $ node run.js\n\n### parallel\n\n> Demonstrate the basic usage of parallel task and syntax.\n\n    $ cd /path/to/node.flow/examples/parallel\n    $ node run.js\n\n### mongoose\n\n> Demonstrate how to clear the documents before inserting a bunch of records then finding some records with given conditions in a loop and show them without writing nested callbacks. Use both series and parallel tasks.\n\n    # make sure your mongoDB is on\n    $ cd /path/to/node.flow/examples/mongoose\n    $ npm install -lf\n    $ node run.js\n\n### node.packer\n\n> Demonstrate how to compress a bunch of files in groups.\n\n    $ cd /path/to/node.flow/examples/node.packer\n    $ npm install -lf\n    $ node app.js\n\n\n\n## License\n\n(The MIT License)\n\nCopyright (c) 2011 dreamerslab &lt;ben@dreamerslab.com&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/dreamerslab/node.flow/issues"
  },
  "homepage": "https://github.com/dreamerslab/node.flow",
  "_id": "node.flow@1.2.3",
  "dist": {
    "shasum": "e1c44a82aeca8d78b458a77fb3dc642f2eba2649",
    "tarball": "http://registry.npmjs.org/node.flow/-/node.flow-1.2.3.tgz"
  },
  "_from": "node.flow@1.2.3",
  "_npmVersion": "1.3.14",
  "_npmUser": {
    "name": "dreamerslab",
    "email": "ben@dreamerslab.com"
  },
  "maintainers": [
    {
      "name": "dreamerslab",
      "email": "ben@dreamerslab.com"
    }
  ],
  "directories": {},
  "_shasum": "e1c44a82aeca8d78b458a77fb3dc642f2eba2649",
  "_resolved": "https://registry.npmjs.org/node.flow/-/node.flow-1.2.3.tgz"
}
